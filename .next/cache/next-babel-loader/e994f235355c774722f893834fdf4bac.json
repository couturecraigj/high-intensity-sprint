{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\nimport { useEffect, useState } from \"react\";\n\nconst useInput = (wrapper = v => v) => {\n  const {\n    0: value,\n    1: setValue\n  } = useState(wrapper(\"\"));\n  return [value, e => setValue(wrapper(e.target.value))];\n};\n\nconst useDistance = () => {\n  function calculateDistance(lat1, lon1, lat2, lon2, unit = \"K\") {\n    if (lat1 == lat2 && lon1 == lon2) {\n      return 0;\n    } else {\n      var radlat1 = Math.PI * lat1 / 180;\n      var radlat2 = Math.PI * lat2 / 180;\n      var theta = lon1 - lon2;\n      var radtheta = Math.PI * theta / 180;\n      var dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);\n\n      if (dist > 1) {\n        dist = 1;\n      }\n\n      dist = Math.acos(dist);\n      dist = dist * 180 / Math.PI;\n      dist = dist * 60 * 1.1515;\n\n      if (unit == \"K\") {\n        dist = dist * 1.609344;\n      }\n\n      if (unit == \"N\") {\n        dist = dist * 0.8684;\n      }\n\n      return dist;\n    }\n  }\n\n  const {\n    0: distance,\n    1: setDistance\n  } = useState();\n  const {\n    0: lastGeopoint,\n    1: setLastGeopoint\n  } = useState([]);\n  const {\n    0: started,\n    1: setStarted\n  } = useState();\n  const {\n    0: rafId,\n    1: setRafId\n  } = useState();\n  const {\n    0: finished,\n    1: setFinished\n  } = useState();\n\n  const start = geopoint => {\n    setFinished(false);\n    setLastGeopoint(geopoint);\n    setDistance(0);\n    setStarted(true);\n    cancelAnimationFrame(rafId);\n  };\n\n  const finish = () => {\n    setLastGeopoint();\n    setFinished(true);\n    cancelAnimationFrame(rafId);\n  };\n\n  const addGeopoint = coords => {\n    if (finished) return;\n    setLastGeopoint(coords);\n  };\n\n  const addDistance = newDistance => {\n    if (finished) return;\n    setDistance(distance + newDistance);\n  };\n\n  const updateTraveled = geopoint => () => {\n    navigator.geolocation.getCurrentPosition(position => {\n      if (geopoint) {\n        addDistance(calculateDistance(geopoint.latitude, geopoint.longitude, position.coords.latitude, position.coords.longitude));\n      }\n\n      console.log(geopoint);\n      addGeopoint(position.coords);\n    }, console.error);\n  };\n\n  useEffect(() => {\n    if (started && !finished) {\n      setRafId(requestAnimationFrame(updateTraveled(lastGeopoint)));\n    }\n\n    if (finished) {\n      cancelAnimationFrame(rafId);\n    }\n\n    if (!lastGeopoint) {\n      cancelAnimationFrame(rafId);\n    }\n  }, [started, finished, lastGeopoint]);\n  return [distance, start, finish];\n};\n\nconst useTimer = () => {\n  const {\n    0: timePassed,\n    1: setTimePassed\n  } = useState();\n  const {\n    0: startTime,\n    1: setStartTime\n  } = useState();\n  const {\n    0: endTime,\n    1: setEndTime\n  } = useState();\n  const {\n    0: rafId,\n    1: setRafId\n  } = useState();\n\n  const startTimer = () => {\n    setEndTime(undefined);\n    setStartTime(performance.now());\n  };\n\n  const stopTimer = () => {\n    setEndTime(performance.now());\n  };\n\n  const updateTimePassed = timeStamp => {\n    setTimePassed(timeStamp - startTime);\n  };\n\n  useEffect(() => {\n    if (startTime && !endTime) {\n      setRafId(requestAnimationFrame(updateTimePassed));\n    }\n\n    if (endTime) {\n      cancelAnimationFrame(rafId);\n    }\n  }, [timePassed, startTime, endTime]);\n  return [timePassed, startTimer, stopTimer];\n};\n\nconst HomePage = () => {\n  const {\n    0: speed,\n    1: setSpeed\n  } = useState();\n  const [lengthOfSprint, setLengthOfSprint] = useInput(v => +v);\n  const [lengthOfBreak, setLengthOfBreak] = useInput(v => +v);\n  const {\n    0: state,\n    1: setState\n  } = useState(\"stop\");\n  const {\n    0: watchId,\n    1: setWatchId\n  } = useState();\n  const [timePassed, startTimer, stopTimer] = useTimer();\n  const [distance, startDistance, stopDistance] = useDistance();\n\n  const stop = () => {\n    stopTimer();\n    stopDistance();\n  };\n\n  const start = geopoint => {\n    startTimer();\n    startDistance(geopoint);\n  };\n\n  useEffect(() => {\n    if (lengthOfSprint && timePassed >= lengthOfSprint) {\n      stop();\n    }\n  }, [lengthOfSprint, timePassed]);\n  useEffect(() => {\n    navigator.geolocation.clearWatch(watchId);\n\n    if (state === \"start\") {\n      start();\n    }\n\n    if (state === \"stop\") {\n      stop();\n    }\n\n    if (state === \"activateOnMove\") {\n      setWatchId(navigator.geolocation.watchPosition(position => {\n        if (position.coords.speed) {\n          setSpeed(position.coords.speed);\n          start(position.coords);\n        }\n      }));\n    }\n  }, [state]);\n  return __jsx(\"div\", null, __jsx(\"div\", null, timePassed ? timePassed.toFixed(2) : \"\"), speed && __jsx(\"div\", null, speed), !!distance && __jsx(\"div\", null, `Traveled: ${distance}KM`), __jsx(\"div\", null, __jsx(\"label\", null, \"How long would you like to sprint?\", __jsx(\"div\", null, __jsx(\"input\", {\n    value: lengthOfSprint,\n    onChange: setLengthOfSprint\n  })))), __jsx(\"div\", null, __jsx(\"label\", null, \"How long would you like to take a break for?\", __jsx(\"div\", null, __jsx(\"input\", {\n    value: lengthOfBreak,\n    onChange: setLengthOfBreak\n  })))), __jsx(\"div\", null, __jsx(\"button\", {\n    type: \"button\",\n    onClick: () => setState(\"start\")\n  }, \"Start Now\"), __jsx(\"button\", {\n    type: \"button\",\n    onClick: () => setState(\"stop\")\n  }, \"Stop Now\"), __jsx(\"button\", {\n    type: \"button\",\n    onClick: () => setState(\"activateOnMove\")\n  }, \"Start Once I move\")));\n};\n\nexport default HomePage;","map":null,"metadata":{},"sourceType":"module"}